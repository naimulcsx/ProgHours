// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  DEMO
  REGULAR
  MENTOR
  ADMIN
}

model User {
  id        String   @id @db.VarChar(50)
  fullName  String   @map("full_name") @db.VarChar(50)
  email     String   @unique @db.VarChar(50)
  username  String   @unique @db.VarChar(25)
  password  String   @db.VarChar(60)
  phone     String?  @db.VarChar(25)
  role      Role     @default(REGULAR)
  lastSeen  DateTime @default(now()) @map("last_seen") @db.Timestamp(0)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(0)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamp(0)
  metaData  Json?    @default("{}") @map("metadata")

  institutionId Int?
  institution   Institution? @relation(fields: [institutionId], references: [id])

  submissions   Submission[]
  userHandles   UserHandle[]
  pullHistories PullHistory[]

  @@map("users")
}

model Problem {
  id              Int               @id @default(autoincrement())
  pid             String            @unique
  name            String
  url             String            @unique
  difficulty      Int
  createdAt       DateTime          @default(now()) @map("created_at") @db.Timestamp(0)
  updatedAt       DateTime          @updatedAt @map("updated_at") @db.Timestamp(0)
  metaData        Json?             @default("{}") @map("metadata")
  problemTags     ProblemTag[]
  submissions     Submission[]
  PullHistoryItem PullHistoryItem[]

  @@map("problems")
}

model Institution {
  id          Int     @id @default(autoincrement())
  name        String
  url         String?
  country     String?
  countryCode String? @map("country_code")
  users       User[]

  @@map("institutions")
}

model Tag {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  problemTags ProblemTag[]

  @@map("tags")
}

model ProblemTag {
  problemId Int @map("problem_id")
  tagId     Int @map("tag_id")

  tag     Tag     @relation(fields: [tagId], references: [id])
  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)

  @@id([problemId, tagId])
  @@map("problem_tags")
}

enum Verdict {
  AC
  PS
  WA
  TLE
  MLE
  RE
  CE
  SK
  OTH
  HCK
}

model Submission {
  id         Int      @id @default(autoincrement())
  solveTime  Int      @map("solve_time")
  verdict    Verdict
  solvedAt   DateTime @map("solved_at") @db.Date
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamp(0)
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamp(0)
  userId     String   @map("user_id") @db.VarChar(50)
  problemId  Int      @map("problem_id")
  isVerified Boolean  @default(false) @map("is_verified")

  acCount  Int @default(0) @map("ac_count") // AC - Accepted
  psCount  Int @default(0) @map("ps_count") // PS - Partially solved
  waCount  Int @default(0) @map("wa_count") // WA - Wrong answer
  tleCount Int @default(0) @map("tle_count") // TLE - Time limit exceeded
  mleCount Int @default(0) @map("mle_count") // MLE - Memory limit exceeded
  reCount  Int @default(0) @map("re_count") // RE - Runtime error
  ceCount  Int @default(0) @map("ce_count") // CE - Compile error
  skCount  Int @default(0) @map("sk_count") // SK - Skipped
  hckCount Int @default(0) @map("hck_count") // HCK - Hacked
  othCount Int @default(0) @map("oth_count") // OTH - Others

  metaData Json? @default("{}") @map("metadata")

  user    User    @relation(fields: [userId], references: [id])
  problem Problem @relation(fields: [problemId], references: [id])

  @@unique([userId, problemId])
  @@index(solvedAt)
  @@map("submissions")
}

enum HandleType {
  CODEFORCES
  CODECHEF
}

model UserHandle {
  id     String     @id @default(cuid())
  user   User       @relation(fields: [userId], references: [id])
  userId String     @map("user_id") @db.VarChar(50)
  type   HandleType
  handle String

  @@unique([userId, type])
  @@map("user_handles")
}

enum PullHistoryStatus {
  PENDING // the pull history has been created
  STARTED // the job is started, totalItems is available
  OK // all items has been fetched
  ERROR // failed
}

model PullHistory {
  id             String            @id @default(cuid())
  user           User              @relation(fields: [userId], references: [id])
  userId         String            @map("user_id") @db.VarChar(50)
  status         PullHistoryStatus @default(PENDING)
  totalCompleted Int               @default(0) @map("total_completed")
  totalItems     Int               @default(0) @map("total_items")
  items          PullHistoryItem[]
  createdAt      DateTime          @default(now()) @map("created_at") @db.Timestamp(0)
  updatedAt      DateTime          @updatedAt @map("updated_at") @db.Timestamp(0)
  processingTime BigInt            @default(0) @map("processing_time")

  @@map("pull_histories")
}

model PullHistoryItem {
  id             Int               @id @default(autoincrement())
  problem        Problem?          @relation(fields: [problemId], references: [id])
  problemId      Int?              @map("problem_id")
  problemUrl     String            @map("problem_url")
  status         PullHistoryStatus @default(PENDING)
  processingTime BigInt            @default(0) @map("processing_time")
  pullHistory    PullHistory       @relation(fields: [pullHistoryId], references: [id], onDelete: Cascade)
  pullHistoryId  String            @map("pull_history_id")
  createdAt      DateTime          @default(now()) @map("created_at") @db.Timestamp(0)
  updatedAt      DateTime          @updatedAt @map("updated_at") @db.Timestamp(0)

  @@index([pullHistoryId])
  @@map("pull_history_items")
}
